# 5. 트랜잭션과 잠금

**트랜잭션**

데이터의 정합성을 보장하기 위한 기능. 논리적인 query의 세트를 완전히 처리하거나, 도중에 실패할 경우 아예 실행되기 이전으로 되돌리는 기능이다.

### 5.1.1 MySQL 트랜잭션

꼭 여러 개의 변경 작업을 수행하는 query가 조합됐을 때만 의미있는 개념은 아니다. 하나의 논리적인 작업셋에 몇개의 query가 있던 상관없이 100% 적용되거나 완전히 실행되기 전으로 되돌아감을 보장하면 된다.

### 5.1.2 주의사항

되도록이면 꼭 필요한 영역에만 트랜잭션을 거는것이 좋다. 트랜잭션의 범위를 최소화하는 것이 좋은데 아래와 같은 트랜잭션이 있다고 가정해보자

```
1) 처리 시작
  => 데이터베이스 커넥션 설정
  => 트랜잭션 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시글 등록에 대한 알림 메일 발송
9) 알림 메일 발송 이력을 DBMS에 저장
	<= 트랜잭션 종료(COMMIT)
	<= 데이터베이스 커넥션 반납
10) 처리 완료
```

위의 절차 중에서 DBMS의 트랜잭션 처리에 좋지 않은 영향을 미치는 부분을 나눠서 살펴보자

**잠금** 

데이터의 `동시성 제어` 위한 기능이다. `동시성 제어`가 왜 필요한지, 하지 않으면 어떤 문제가 발생할 수 있는지 확인해보자 

1. 갱신내용 손실

   동시성 제어를 하지 않는다고 가정하고 `게시글 테이블`에 `조회수` 필드가 있고 A게시글이 있다고 가정해보자

   ```mysql
   A 게시글의 조회수 1
   ```

   이 게시글에 동시에 2명의 회원이 A 게시글을 조회하면 연속적으로 조회수를 업데이트하는 query가 2번 실행된다. 일반적으로 `select -> update`로 query를 실행시키는데 여기서 문제가 발생한다.

   ```tex
   첫번째 query : (A 게시글의 조회수 1) ----> (조회수+1) ----> 조회수 2가됨
   두번째 query :            (A 게시글의 조회수 1)  ------> (조회수+1) ----> 조회수 2가됨
   시간의 흐름   : ----> t1 ----> t2 ----> t3 ----> t4 ----> ----> t5
   ```

   상식적으로 조회수는 총 3이 되어야하지만 두번째 query가 A게시글의 조회수를 확인한 시점이 첫번째 query의 업데이트가 끝나기 전이었기 때문에 조회수 1로 인식해버리고 그것때문에 조회수 + 1이라는 갱신내용이 손실되는 결과를 낳는다.

2. 현행파악 오류

   트랜잭션이 다른 트랜잭션에서 변경은 되었으나 커밋은 되지 않은 정보를 select하는 경우 발생하는 문제, 커밋되지 않고 롤백되는 경우 이전 데이터를 보여주어야하는데, 마치 변경이 반영된것마냥 보여질 수 있다.





트랜잭션 : 데이터의 정합성을 보장하기 위한 기능

잠금 : 데이터의 동시성을 제어하기 위한 기능

>  **동시성이란?** 데이터베이스에 다수의 사용자가 동시에 접근하는 상황이 빈번하게 발생하는데, 이들에 대한 적절한 통제가 이루어지지 않는다면, 데이터의 무결성이 깨지게 될 것이다. 동시성은 데이터베이스가 항상 일관되고 정확한 데이터를 반환하게 한다.